<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Protected Media Player</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1 {
            color: #333;
            text-align: center;
        }
        
        .media-container {
            background-color: #fff;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        #mediaCanvas {
            width: 100%;
            border-radius: 4px;
            margin-top: 20px;
            background-color: #000;
        }
        
        #mediaElement {
            display: none; /* Hide the actual media element */
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #3367d6;
        }
        
        .status {
            text-align: center;
            color: #666;
            font-style: italic;
            margin-top: 10px;
        }
        
        .watermark {
            position: absolute;
            bottom: 60px;
            right: 30px;
            color: white;
            font-size: 18px;
            opacity: 0.6;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            z-index: 2;
            user-select: none;
        }
        
        #progressBar {
            width: 100%;
            height: 5px;
            background-color: #ddd;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        #progress {
            height: 100%;
            background-color: #4285f4;
            width: 0%;
            transition: width 0.3s;
        }
        
        #volumeControl {
            margin-top: 10px;
            width: 100%;
        }
        
        .error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
            display: none;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .error-overlay h2 {
            color: #ff4d4d;
            margin-bottom: 20px;
        }
        
        .error-overlay p {
            max-width: 80%;
        }
    </style>
</head>
<body>
    <h1>Advanced Protected Media Player</h1>
    
    <div class="media-container">
        <!-- Hidden media elements for content loading only -->
        <video id="mediaElement" crossorigin="anonymous"></video>
        <audio id="audioElement" crossorigin="anonymous"></audio>
        
        <!-- Canvas where we'll render the media frames -->
        <canvas id="mediaCanvas"></canvas>
        
        <!-- Audio context for processing audio -->
        <div id="audioVisualizer"></div>
        
        <!-- Progress bar -->
        <div id="progressBar">
            <div id="progress"></div>
        </div>
        
        <div id="watermark" class="watermark"></div>
        
        <div class="status" id="status">Initializing secure player...</div>
        
        <div class="controls">
            <button id="playPauseBtn">Play</button>
            <button id="stopBtn">Stop</button>
            <button id="muteBtn">Mute</button>
            <button id="fullscreenBtn">Fullscreen</button>
        </div>
        
        <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="1">
        
        <!-- Error overlay for security violations -->
        <div class="error-overlay" id="errorOverlay">
            <h2>Playback Stopped</h2>
            <p id="errorMessage">Security violation detected. Media playback has been terminated.</p>
        </div>
    </div>
    
    <script>
        // Get DOM elements
        const mediaElement = document.getElementById('mediaElement');
        const audioElement = document.getElementById('audioElement');
        const mediaCanvas = document.getElementById('mediaCanvas');
        const ctx = mediaCanvas.getContext('2d');
        const watermark = document.getElementById('watermark');
        const status = document.getElementById('status');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const muteBtn = document.getElementById('muteBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const volumeControl = document.getElementById('volumeControl');
        const progress = document.getElementById('progress');
        const errorOverlay = document.getElementById('errorOverlay');
        const errorMessage = document.getElementById('errorMessage');
        
        // Security variables
        let sessionToken = "";
        let userFingerprint = "";
        let isPlaying = false;
        let frameId = null;
        let mediaSegments = [];
        let currentSegment = 0;
        let segmentSources = [];
        let encryptionKeys = [];
        let segmentLoaded = false;
        let frameCounter = 0;
        let audioContext = null;
        let audioProcessor = null;
        let mediaSource = null;
        let mediaBuffer = null;
        let lastRequestTime = 0;
        let securityChecksInterval = null;
        let webRTCLeakDetectionInterval = null;
        let networkLatencyCheckInterval = null;
        let suspiciousActivityDetected = false;
        let connectionBaselineSet = false;
        let baselineLatencies = [];
        let baselinePingResults = {};
        let previousIPs = [];
        
        // Audio processing variables
        let audioAnalyser = null;
        let audioGain = null;
        let audioData = new Uint8Array(0);
        
        // Show security violation overlay and stop playback
        function showSecurityViolation(message) {
            if (suspiciousActivityDetected) return; // Already detected
            
            suspiciousActivityDetected = true;
            
            // Log the violation to server (in a real implementation)
            logSecurityViolation(message);
            
            // Stop all media and processing
            if (isPlaying) {
                mediaElement.pause();
                cancelAnimationFrame(frameId);
                isPlaying = false;
            }
            
            // Clear any sensitive data
            wipeSecurityData();
            
            // Show the error overlay
            errorMessage.textContent = message;
            errorOverlay.style.display = 'flex';
            
            // Stop all security check intervals
            clearAllIntervals();
        }
        
        // Log security violation to server
        function logSecurityViolation(message) {
            // In a real implementation, this would securely log the violation
            // along with user data to your server
            
            const violationData = {
                fingerprint: userFingerprint,
                timestamp: new Date().toISOString(),
                message: message,
                userAgent: navigator.userAgent,
                location: window.location.href
            };
            
            // Simulated server logging - in production, this would be a secure endpoint
            console.log("Security violation logged:", violationData);
            
            // You would typically send this data to your server
            /*
            fetch('https://yourserver.com/api/security/log', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(violationData),
            });
            */
        }
        
        // Clear all security check intervals
        function clearAllIntervals() {
            if (securityChecksInterval) clearInterval(securityChecksInterval);
            if (webRTCLeakDetectionInterval) clearInterval(webRTCLeakDetectionInterval);
            if (networkLatencyCheckInterval) clearInterval(networkLatencyCheckInterval);
        }
        
        // Wipe sensitive security data
        function wipeSecurityData() {
            // Clear encryption keys and tokens
            encryptionKeys = [];
            sessionToken = "";
            
            // Release media resources
            if (mediaSource && mediaSource.readyState === 'open') {
                try {
                    mediaSource.endOfStream();
                } catch (e) { /* Ignore errors during cleanup */ }
            }
            
            // Clear source URLs
            mediaElement.src = "";
            audioElement.src = "";
            
            // Clear any cached data
            segmentSources = [];
            mediaSegments = [];
        }
        
        // Initialize Web Audio API
        function initAudio() {
            try {
                // Create audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create audio source from media element
                const source = audioContext.createMediaElementSource(mediaElement);
                
                // Create analyser for visualizations
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 256;
                audioData = new Uint8Array(audioAnalyser.frequencyBinCount);
                
                // Create gain node for volume control
                audioGain = audioContext.createGain();
                
                // Connect nodes: source -> gain -> analyser -> destination
                source.connect(audioGain);
                audioGain.connect(audioAnalyser);
                audioAnalyser.connect(audioContext.destination);
                
                return true;
            } catch (error) {
                console.error("Audio initialization error:", error);
                return false;
            }
        }
        
        // Encrypt data using AES
        async function encryptData(data, key) {
            const encoder = new TextEncoder();
            const keyData = encoder.encode(key);
            
            // Use subtle crypto for encryption
            const cryptoKey = await window.crypto.subtle.importKey(
                "raw", 
                keyData, 
                {name: "AES-GCM"}, 
                false, 
                ["encrypt"]
            );
            
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            const encryptedData = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                cryptoKey,
                data
            );
            
            // Combine IV and encrypted data
            const result = new Uint8Array(iv.length + encryptedData.byteLength);
            result.set(iv, 0);
            result.set(new Uint8Array(encryptedData), iv.length);
            
            return result;
        }
        
        // Decrypt data using AES
        async function decryptData(data, key) {
            // Extract IV (first 12 bytes)
            const iv = data.slice(0, 12);
            const encryptedData = data.slice(12);
            
            const encoder = new TextEncoder();
            const keyData = encoder.encode(key);
            
            // Use subtle crypto for decryption
            const cryptoKey = await window.crypto.subtle.importKey(
                "raw", 
                keyData, 
                {name: "AES-GCM"}, 
                false, 
                ["decrypt"]
            );
            
            const decryptedData = await window.crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                cryptoKey,
                encryptedData
            );
            
            return decryptedData;
        }
        
        // Generate a random session token
        function generateSessionToken(length = 32) {
            const array = new Uint8Array(length);
            window.crypto.getRandomValues(array);
            return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
        }
        
        // Generate a fingerprint based on browser information
        function generateFingerprint() {
            const screenInfo = `${window.screen.width}x${window.screen.height}x${window.screen.colorDepth}`;
            const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const browser = navigator.userAgent;
            const languages = navigator.languages ? navigator.languages.join(',') : navigator.language;
            
            // Use subtle crypto to hash the fingerprint
            const data = screenInfo + timeZone + browser + languages;
            const encoder = new TextEncoder();
            const dataBuffer = encoder.encode(data);
            
            return window.crypto.subtle.digest('SHA-256', dataBuffer)
                .then(hash => {
                    return Array.from(new Uint8Array(hash))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('')
                        .substring(0, 24);
                });
        }
        
        // Create dynamic watermark with user information
        function createWatermark() {
            const date = new Date().toISOString();
            const id = userFingerprint.substring(0, 8);
            watermark.textContent = `ID: ${id} • ${date}`;
            
            // Update watermark position randomly
            setInterval(() => {
                watermark.style.right = `${20 + Math.random() * 60}px`;
                watermark.style.bottom = `${40 + Math.random() * 40}px`;
            }, 30000);
        }
        
        // Initialize security measures
        async function initSecurity() {
            // Generate session token
            sessionToken = generateSessionToken();
            
            // Generate user fingerprint
            userFingerprint = await generateFingerprint();
            
            // Create encryption keys for segments
            for (let i = 0; i < 5; i++) {
                encryptionKeys.push(generateSessionToken(16));
            }
            
            status.textContent = "Establishing secure connection...";
            
            // Set up routine security checks
            startSecurityMonitoring();
            
            return new Promise((resolve) => {
                setTimeout(() => {
                    status.textContent = "Connection secured. Preparing media...";
                    resolve();
                }, 1000);
            });
        }
        
        // ==========================================
        // SECURITY AND MONITORING FUNCTIONS
        // ==========================================
        
        // Start all security monitoring tasks
        function startSecurityMonitoring() {
            // Run continuous security checks
            securityChecksInterval = setInterval(runSecurityChecks, 3000);
            
            // Set up WebRTC leak detection
            webRTCLeakDetectionInterval = setInterval(detectWebRTCLeaks, 5000);
            
            // Set up network latency monitoring
            networkLatencyCheckInterval = setInterval(checkNetworkLatency, 2000);
            
            // Immediately run initial checks
            runSecurityChecks();
            detectWebRTCLeaks();
            establishConnectionBaseline();
        }
        
        // Run various security checks
        function runSecurityChecks() {
            if (suspiciousActivityDetected) return;
            
            Promise.all([
                detectDevTools(),
                detectVPN(),
                detectProxies(),
                detectDebuggerAttached(),
                detectPacketCapture(),
                checkTamperingAttempts(),
                detectVirtualMachine()
            ]).then(results => {
                const [devTools, vpn, proxies, debugger_, packetCapture, tampering, vm] = results;
                
                if (devTools) {
                    showSecurityViolation("Developer tools detected. Playback terminated.");
                } else if (vpn) {
                    showSecurityViolation("VPN or proxy detected. Playback terminated.");
                } else if (proxies) {
                    showSecurityViolation("Network proxy detected. Playback terminated.");
                } else if (debugger_) {
                    showSecurityViolation("Debugging tools detected. Playback terminated.");
                } else if (packetCapture) {
                    showSecurityViolation("Packet capture tools detected. Playback terminated.");
                } else if (tampering) {
                    showSecurityViolation("Code tampering detected. Playback terminated.");
                } else if (vm) {
                    showSecurityViolation("Virtual machine environment detected. Playback terminated.");
                }
            }).catch(error => {
                console.error("Security check error:", error);
            });
        }
        
        // Detect if developer tools are open
        function detectDevTools() {
            return new Promise(resolve => {
                // Check if the window has been resized - might indicate dev tools
                const widthThreshold = window.outerWidth - window.innerWidth > 200;
                const heightThreshold = window.outerHeight - window.innerHeight > 200;
                
                // Check for Firefox dev tools using firebug
                const firefoxDevTools = typeof window.console.profile === 'function';
                
                // Check for specific dev tool elements
                let devToolsPresent = false;
                const divTool = document.createElement('div');
                Object.defineProperty(divTool, 'id', {
                    get: function() {
                        devToolsPresent = true;
                        return 'id';
                    }
                });
                console.log(divTool);
                console.clear();
                
                resolve(widthThreshold || heightThreshold || firefoxDevTools || devToolsPresent);
            });
        }
        
        // Detect VPN by checking for discrepancies between connection info
        function detectVPN() {
            return new Promise(resolve => {
                // Check for timezone/locale inconsistencies
                // This can reveal VPN usage where the region doesn't match
                const date = new Date();
                const timeZoneOffset = date.getTimezoneOffset();
                const expectedLanguage = navigator.language || navigator.userLanguage;
                
                // Get geolocation if available (will only work if user grants permission)
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            // Compare timezone with geolocation
                            // This is a simplified check - a real implementation would use
                            // a more sophisticated algorithm
                            
                            // For demo purposes, let's say we detect VPN if WebRTC leaks show
                            // multiple different IPs (checked in detectWebRTCLeaks)
                            resolve(false); // Let WebRTC detection handle this
                        },
                        function(error) {
                            // Geolocation refused - slightly suspicious but not conclusive
                            resolve(false);
                        }
                    );
                } else {
                    // Geolocation not available
                    resolve(false);
                }
            });
        }
        
        // Detect proxy settings
        function detectProxies() {
            return new Promise(resolve => {
                // Check if connection timing is suspicious
                // VPNs and proxies typically add latency
                
                // Start with false - networkLatencyCheck will handle this
                resolve(false);
            });
        }
        
        // Detect if a debugger is attached
        function detectDebuggerAttached() {
            return new Promise(resolve => {
                // Check if debugger keywords are defined
                const hasDebugger = /debug|debugger|devtools/i.test(window.location.href);
                
                // Check for common debugging function availability
                const debugFunctions = typeof console.debug === 'function';
                
                // Check execution time of a simple operation (debuggers slow this down)
                const start = performance.now();
                for (let i = 0; i < 100; i++) {
                    console.log(i);
                    console.clear();
                }
                const end = performance.now();
                const debuggerSuspected = (end - start) > 100; // Threshold in ms
                
                resolve(hasDebugger || debuggerSuspected);
            });
        }
        
        // Detect packet capture tools
        function detectPacketCapture() {
            return new Promise(resolve => {
                // This is challenging to detect directly in the browser
                // We'll use indirect methods:
                
                // 1. Check for suspicious network timing behavior
                const suspiciousLatency = checkForSuspiciousNetworkBehavior();
                
                // 2. Check for known packet capture extensions
                const hasPacketCaptureExtensions = checkForPacketCaptureExtensions();
                
                // 3. Look for browser plugins that might be used for traffic analysis
                const suspiciousPlugins = checkSuspiciousPlugins();
                
                resolve(suspiciousLatency || hasPacketCaptureExtensions || suspiciousPlugins);
            });
        }
        
        // Check if the page or JavaScript has been tampered with
        function checkTamperingAttempts() {
            return new Promise(resolve => {
                // Check if our script has been modified
                const expectedChecksum = "abcdef123456"; // This would be a hash of the original script
                
                // In a real implementation, you would calculate a checksum of this script
                // and compare it to the expected value
                
                // For demo purposes, check if any functions have been overridden
                const originalFetch = window.fetch;
                const originalXHR = window.XMLHttpRequest;
                const originalWebSocket = window.WebSocket;
                
                const fetchOverridden = window.fetch !== originalFetch;
                const xhrOverridden = window.XMLHttpRequest !== originalXHR;
                const websocketOverridden = window.WebSocket !== originalWebSocket;
                
                resolve(fetchOverridden || xhrOverridden || websocketOverridden);
            });
        }
        
        // Detect if running in a virtual machine
        function detectVirtualMachine() {
            return new Promise(resolve => {
                // Check for hardware concurrency - VMs often have limited cores
                const lowConcurrency = navigator.hardwareConcurrency <= 1;
                
                // Check for VM-like device memory
                const suspiciousMemory = navigator.deviceMemory === 1;
                
                // Check for common VM screen resolutions
                const vmResolution = (window.screen.width === 1024 && window.screen.height === 768) || 
                                    (window.screen.width === 800 && window.screen.height === 600);
                
                // In a real implementation, you would use more sophisticated checks
                resolve(false); // Disable for demo, would be: (lowConcurrency && suspiciousMemory) || vmResolution
            });
        }
        
        // Check for packet capture extensions
        function checkForPacketCaptureExtensions() {
            // This is a simplified check - in reality this is difficult to detect
            // as extensions are sandboxed
            
            // Check for web accessible resources from known extensions
            const packetCaptureExtElements = document.querySelectorAll('link[href*="wireshark"], link[href*="fiddler"], link[href*="packet"]');
            
            return packetCaptureExtElements.length > 0;
        }
        
        // Check for suspicious plugins
        function checkSuspiciousPlugins() {
            if (!navigator.plugins) return false;
            
            // Look for plugins with suspicious names
            for (let i = 0; i < navigator.plugins.length; i++) {
                const pluginName = navigator.plugins[i].name.toLowerCase();
                if (pluginName.includes('wireshark') || 
                    pluginName.includes('fiddler') || 
                    pluginName.includes('packet') ||
                    pluginName.includes('capture') ||
                    pluginName.includes('sniff')) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check for suspicious network behavior
        function checkForSuspiciousNetworkBehavior() {
            // This would need to compare against established baselines
            // For demo purposes, return false
            return false;
        }
        
        // Detect WebRTC leaks that could reveal VPN usage
        function detectWebRTCLeaks() {
            if (suspiciousActivityDetected || !window.RTCPeerConnection) return;
            
            const iceServers = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            const pc = new RTCPeerConnection(iceServers);
            const ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
            const ipAddresses = [];
            
            pc.createDataChannel('');
            
            pc.onicecandidate = (e) => {
                if (!e.candidate) return;
                
                const match = ipRegex.exec(e.candidate.candidate);
                if (match) {
                    const ipAddress = match[1];
                    // Check if private IP
                    if (ipAddress.match(/(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/)) {
                        // This is a private IP - store it for comparison
                        if (!ipAddresses.includes(ipAddress)) {
                            ipAddresses.push(ipAddress);
                        }
                    } else {
                        // Public IP - store for comparison
                        if (!ipAddresses.includes(ipAddress)) {
                            ipAddresses.push(ipAddress);
                        }
                    }
                }
                
                // Check for VPN/Proxy by comparing current IPs with previous
                if (previousIPs.length > 0) {
                    for (let ip of ipAddresses) {
                        if (previousIPs.includes(ip)) continue;
                        
                        // IP address changed during the session - potential VPN/proxy
                        showSecurityViolation("IP address change detected. VPN/proxy suspected.");
                        break;
                    }
                }
                
                // Update previous IPs
                previousIPs = [...ipAddresses];
                
                // Multiple different public IPs suggests VPN/proxy
                const publicIPs = ipAddresses.filter(ip => 
                    !ip.match(/(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/)
                );
                
                if (publicIPs.length > 1) {
                    showSecurityViolation("Multiple public IP addresses detected. VPN/proxy suspected.");
                    pc.close();
                }
            };
            
            // Set up connection
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .catch(() => {});
                
            // Close after a timeout
            setTimeout(() => pc.close(), 1000);
        }
        
        // Establish connection baseline for later comparisons
        function establishConnectionBaseline() {
            if (connectionBaselineSet) return;
            
            // Measure latencies to different endpoints
            const endpoints = [
                { url: 'https://www.google.com/favicon.ico', name: 'google' },
                { url: 'https://www.microsoft.com/favicon.ico', name: 'microsoft' },
                { url: 'https://www.amazon.com/favicon.ico', name: 'amazon' }
            ];
            
            const latencyChecks = endpoints.map(endpoint => {
                return measureLatency(endpoint.url)
                    .then(latency => {
                        return { name: endpoint.name, latency };
                    })
                    .catch(() => {
                        return { name: endpoint.name, latency: -1 };
                    });
            });
            
            Promise.all(latencyChecks).then(results => {
                results.forEach(result => {
                    if (result.latency > 0) {
                        baselinePingResults[result.name] = result.latency;
                        baselineLatencies.push(result.latency);
                    }
                });
                
                connectionBaselineSet = baselineLatencies.length > 0;
            });
        }
        
        // Measure latency to an endpoint
        function measureLatency(url) {
            return new Promise((resolve, reject) => {
                const startTime = performance.now();
                
                fetch(url + '?nocache=' + Math.random(), { 
                    method: 'HEAD',
                    mode: 'no-cors',
                    cache: 'no-store'
                })
                .then(() => {
                    const endTime = performance.now();
                    resolve(endTime - startTime);
                })
                .catch(error => {
                    reject(error);
                });
            });
        }
        
        // Check for unusual changes in network latency that might indicate a VPN or packet capture
        function checkNetworkLatency() {
            if (!connectionBaselineSet || suspiciousActivityDetected) return;
            
            // Pick a random endpoint to check
            const endpoints = [
                { url: 'https://www.google.com/favicon.ico', name: 'google' },
                { url: 'https://www.microsoft.com/favicon.ico', name: 'microsoft' },
                { url: 'https://www.amazon.com/favicon.ico', name: 'amazon' }
            ];
            
            const endpoint = endpoints[Math.floor(Math.random() * endpoints.length)];
            
            measureLatency(endpoint.url).then(latency => {
                const baselineLatency = baselinePingResults[endpoint.name];
                
                if (baselineLatency && latency > 0) {
                    // Calculate difference as a percentage
                    const difference = Math.abs(latency - baselineLatency) / baselineLatency;
                    
                    // If latency has increased dramatically (300%+), might indicate VPN or packet capture was enabled
                    if (difference > 3 && latency > baselineLatency) {
                        showSecurityViolation("Unusual network latency detected. VPN or capture tools suspected.");
                    }
                }
            }).catch(() => {
                // Network error, but not necessarily suspicious
            });
        }
        
        // Create a secure URL that doesn't reveal the actual media path
        function createSecureURL(index, mediaType) {
            // Instead of direct URLs, use a proxy endpoint that validates session tokens
            const proxyEndpoint = "secureMediaProxy";
            
            // Create a secure payload
            const payload = {
                session: sessionToken,
                fingerprint: userFingerprint,
                mediaType: mediaType,
                segmentIndex: index,
                timestamp: Date.now()
            };
            
            // Encode the payload
            const encodedPayload = btoa(JSON.stringify(payload));
            
            // Generate a secure URL that doesn't reveal the actual media source
            const randomParam = Math.floor(Math.random() * 1000000);
            return `${proxyEndpoint}?token=${encodedPayload}&nocache=${randomParam}`;
        }
        
        // Simulate creating encrypted media segments
        function createMediaSegments() {
            // Generate secure URLs for each segment that don't reveal actual paths
            segmentSources = [];
            for (let i = 0; i < 5; i++) {
                segmentSources
                // Complete the createMediaSegments function that was cut off
function createMediaSegments() {
    // Generate secure URLs for each segment that don't reveal actual paths
    segmentSources = [];
    for (let i = 0; i < 5; i++) {
        segmentSources.push({
            video: createSecureURL(i, 'video'),
            audio: createSecureURL(i, 'audio'),
            key: encryptionKeys[i]
        });
    }
    
    // In a real implementation, these would be actual media segments
    // For demo purposes, we'll use placeholders
    mediaSegments = [
        { duration: 30, loaded: false },
        { duration: 30, loaded: false },
        { duration: 30, loaded: false },
        { duration: 30, loaded: false },
        { duration: 30, loaded: false }
    ];
    
    return new Promise(resolve => {
        status.textContent = "Media prepared. Establishing secure playback...";
        setTimeout(resolve, 1000);
    });
}

// Load a media segment
async function loadMediaSegment(index) {
    if (index >= segmentSources.length || suspiciousActivityDetected) {
        return false;
    }
    
    // Simulate loading encrypted segment
    return new Promise(resolve => {
        status.textContent = `Loading segment ${index + 1}...`;
        
        // In a real implementation, this would fetch and decrypt the actual media
        setTimeout(() => {
            mediaSegments[index].loaded = true;
            status.textContent = index === 0 ? "Ready to play" : "Loading next segment...";
            resolve(true);
        }, 500);
    });
}

// Play the media
async function playMedia() {
    if (suspiciousActivityDetected) return;
    
    if (!isPlaying) {
        // Make sure first segment is loaded
        if (!mediaSegments[0].loaded) {
            await loadMediaSegment(0);
        }
        
        // Start playback
        status.textContent = "Playing...";
        isPlaying = true;
        playPauseBtn.textContent = "Pause";
        
        // Start rendering frames
        mediaElement.play();
        renderFrame();
        
        // Start loading other segments in background
        loadNextSegments();
    } else {
        // Pause playback
        mediaElement.pause();
        cancelAnimationFrame(frameId);
        isPlaying = false;
        playPauseBtn.textContent = "Play";
        status.textContent = "Paused";
    }
}

// Load upcoming segments in the background
async function loadNextSegments() {
    for (let i = currentSegment + 1; i < mediaSegments.length; i++) {
        if (!mediaSegments[i].loaded) {
            await loadMediaSegment(i);
        }
    }
}

// Render a video frame to canvas
function renderFrame() {
    if (!isPlaying || suspiciousActivityDetected) return;
    
    // Get canvas dimensions
    const width = mediaCanvas.width;
    const height = mediaCanvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Draw the video frame to canvas
    if (mediaElement.readyState >= 2) {
        ctx.drawImage(mediaElement, 0, 0, width, height);
    }
    
    // Apply obfuscation techniques to prevent screen recording
    applyAntiScreenCaptureEffects();
    
    // Draw watermark directly on frames
    updateDynamicWatermark();
    
    // Update audio visualization if available
    if (audioAnalyser) {
        audioAnalyser.getByteFrequencyData(audioData);
        visualizeAudio();
    }
    
    // Update progress
    updateProgress();
    
    // Increment frame counter (used for various security checks)
    frameCounter++;
    
    // Continue rendering frames
    frameId = requestAnimationFrame(renderFrame);
}

// Apply effects that make screen recording more difficult
function applyAntiScreenCaptureEffects() {
    // Every few seconds, briefly add visual noise that's less visible to human eye
    // but disrupts many recording tools
    if (frameCounter % 300 === 0) { // Approximately every 5 seconds at 60fps
        const width = mediaCanvas.width;
        const height = mediaCanvas.height;
        
        // Create subtle pattern
        ctx.globalAlpha = 0.03; // Very subtle
        
        // Draw random pixels
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        for (let i = 0; i < data.length; i += 16) { // Only modify every 4th pixel
            if (Math.random() > 0.95) { // Only 5% of pixels
                data[i] = data[i] ^ 1; // XOR the least significant bit
            }
        }
        
        ctx.putImageData(imageData, 0, 0);
        ctx.globalAlpha = 1.0;
    }
}

// Update dynamic watermark with movement and changing info
function updateDynamicWatermark() {
    if (frameCounter % 600 === 0) { // Update every 10 seconds at 60fps
        createWatermark(); // Update watermark text
    }
}

// Visualize audio in canvas
function visualizeAudio() {
    if (!audioData || !ctx) return;
    
    const width = mediaCanvas.width;
    const height = mediaCanvas.height;
    const barWidth = width / audioData.length;
    
    ctx.save();
    ctx.globalAlpha = 0.15; // Make it subtle
    
    // Draw at bottom of video
    const visualizerHeight = height * 0.1;
    const visualizerY = height - visualizerHeight;
    
    for (let i = 0; i < audioData.length; i++) {
        const barHeight = (audioData[i] / 255) * visualizerHeight;
        ctx.fillStyle = `rgba(255, 255, 255, 0.5)`;
        ctx.fillRect(i * barWidth, visualizerY + visualizerHeight - barHeight, barWidth, barHeight);
    }
    
    ctx.restore();
}

// Update progress bar
function updateProgress() {
    // Calculate total duration
    const totalDuration = mediaSegments.reduce((sum, segment) => sum + segment.duration, 0);
    
    // Calculate current position based on current segment and media element time
    const segmentStartTime = mediaSegments.slice(0, currentSegment).reduce((sum, segment) => sum + segment.duration, 0);
    const currentPosition = segmentStartTime + mediaElement.currentTime;
    
    // Update progress bar
    const progressPercent = (currentPosition / totalDuration) * 100;
    progress.style.width = `${progressPercent}%`;
}

// Initialize the player
async function initPlayer() {
    try {
        // Set canvas size
        mediaCanvas.width = 640;
        mediaCanvas.height = 360;
        
        // Draw loading screen
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, mediaCanvas.width, mediaCanvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Initializing secure player...', mediaCanvas.width / 2, mediaCanvas.height / 2);
        
        // Initialize security measures
        await initSecurity();
        
        // Initialize audio
        const audioInitialized = initAudio();
        
        // Create media segments
        await createMediaSegments();
        
        // Load first segment
        await loadMediaSegment(0);
        
        // Create watermark
        createWatermark();
        
        // Add event listeners
        playPauseBtn.addEventListener('click', playMedia);
        stopBtn.addEventListener('click', stopMedia);
        muteBtn.addEventListener('click', toggleMute);
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        volumeControl.addEventListener('input', changeVolume);
        
        // Set up MediaSource for streaming
        setupMediaSource();
        
        status.textContent = "Ready to play";
    } catch (error) {
        console.error("Player initialization error:", error);
        status.textContent = "Error initializing player";
    }
}

// Set up MediaSource for streaming
function setupMediaSource() {
    try {
        mediaSource = new MediaSource();
        mediaElement.src = URL.createObjectURL(mediaSource);
        
        mediaSource.addEventListener('sourceopen', () => {
            // Create source buffer
            mediaBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
            
            // In a real implementation, you would add encrypted segments to the buffer
            
            status.textContent = "Media source ready";
        });
    } catch (e) {
        console.error("MediaSource setup error:", e);
    }
}

// Stop media playback
function stopMedia() {
    if (isPlaying) {
        mediaElement.pause();
        mediaElement.currentTime = 0;
        cancelAnimationFrame(frameId);
        isPlaying = false;
        playPauseBtn.textContent = "Play";
        status.textContent = "Stopped";
    }
}

// Toggle mute
function toggleMute() {
    mediaElement.muted = !mediaElement.muted;
    muteBtn.textContent = mediaElement.muted ? "Unmute" : "Mute";
}

// Toggle fullscreen
function toggleFullscreen() {
    const container = document.querySelector('.media-container');
    
    if (!document.fullscreenElement) {
        if (container.requestFullscreen) {
            container.requestFullscreen();
        } else if (container.webkitRequestFullscreen) {
            container.webkitRequestFullscreen();
        } else if (container.msRequestFullscreen) {
            container.msRequestFullscreen();
        }
        fullscreenBtn.textContent = "Exit Fullscreen";
    } else {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
        fullscreenBtn.textContent = "Fullscreen";
    }
}

// Change volume
function changeVolume() {
    const volume = volumeControl.value;
    mediaElement.volume = volume;
    
    if (audioGain) {
        audioGain.gain.value = volume;
    }
}

// Handle fullscreen change
document.addEventListener('fullscreenchange', updateFullscreenButton);
document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
document.addEventListener('msfullscreenchange', updateFullscreenButton);

function updateFullscreenButton() {
    if (document.fullscreenElement) {
        fullscreenBtn.textContent = "Exit Fullscreen";
    } else {
        fullscreenBtn.textContent = "Fullscreen";
    }
}

// Initialize the player when the page loads
window.addEventListener('load', initPlayer);

// Clean up when page is unloaded
window.addEventListener('beforeunload', () => {
    clearAllIntervals();
    if (mediaElement) mediaElement.src = "";
    if (audioElement) audioElement.src = "";
    if (mediaSource && mediaSource.readyState === 'open') {
        try {
            mediaSource.endOfStream();
        } catch (e) { /* Ignore errors during cleanup */ }
    }
});
